把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并

舉例

有一個問題要將 arr 排序 [5,7,3,1]。暴力解法就是全部走一次，找到最小的往第一個放，以此類推。

而Divide and conquer 的概念就是我們先將問題拆開成小問題，然後每個小問題的解法合併，大問題就解決了。很攏統，我們直接來看例子

原本目標是 arr 排序 [5,7,3,1]，我就”拆”成先 [5,7] 跟 [3,1]。再拆成 ([5], [7]) , ([3], [1])，直到我拆到沒東西拆。好了之後，我們要合併，在這個題目的合併就是排序，所以我先排 5,7 再排出 1,3。你可能會問，這樣哪裡省效能了？你會發現，因為合併後是有序的數列，所以你可以只比較第一個數然後合併。所以你只需要 O(n)

時間複雜度討論

## 拆

剛剛有提到，拆就是無腦切半切半。一個蘋果如果要切成4片，要切3刀，也就是 n-1。

## 合併

合併分成合的時候，要每個都比過，所以會是 O(n)，合幾次呢？假設以上題來說，n =4 的情況下要 2 次，也就是 logn。所以是 n*logn

(n-1) + n*logn 只計最高項係數並省略常數，因此我們終於得到合併排序法的時間複雜度，即為 O( n log n)。

## Recommend Reference Resource
[初學者學演算法｜排序法進階：合併排序法](https://medium.com/appworks-school/%E5%88%9D%E5%AD%B8%E8%80%85%E5%AD%B8%E6%BC%94%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%E6%B3%95%E9%80%B2%E9%9A%8E-%E5%90%88%E4%BD%B5%E6%8E%92%E5%BA%8F%E6%B3%95-6252651c6f7e)